{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}
forall X -> int is_null? (X x) asm "ISNULL";
forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";

() recv_internal() {
}


(cell) pack_chars(tuple chars, cell prev_cell){
  builder c = begin_cell();

  while (~ is_null?(chars)) {
    if (c.builder_bits() + 8 > 1023) {
      return pack_chars(chars, c.end_cell());
    }
    int char = chars~pop_back();
    c~store_uint(char, 8);
  }
  if (~ prev_cell.begin_parse().slice_empty?()) {
    return c.store_ref(prev_cell).end_cell();
  }
  return c.end_cell();
}

(tuple, builder) c(tuple chars, slice msg, int shift, builder ans) {
  while (~ msg.slice_empty?()) {
    if (msg.slice_data_empty?()) {
      msg = msg~load_ref().begin_parse();
    }
    int char = msg~load_uint(8);
    int upper_case? = (64 < char) & (char < 91);
    int lower_case? = (96 < char) & (char < 123);
    if (upper_case?) {
      char = ((char + (shift % 26) - 65) % 26) + 65;
    } if (lower_case?) {
      char = ((char + (shift % 26) - 97) % 26) + 97;
    }
    if (~ (ans.builder_bits() + 8 > 1023)) {
      ans~store_uint(char, 8);
    } else {
      (chars, ans) = c(chars, msg, shift, ans);
      chars~push_back(char);
      return (chars, ans);
    }
  }
  return (chars, ans);
}

(cell) cipher(int decrypt?, cell text, int shift) {
  if (shift == 0) {
    return text;
  }
  if (decrypt?) {
    shift = 26 - shift;
  }
  slice msg = text.begin_parse();
  msg~skip_bits(32);

  tuple chars = null();
  builder ans = begin_cell();
  ans~store_uint(0, 32);

  (tuple ch, ans) = c(null(), msg, shift, ans);
  cell chars = pack_chars(ch, begin_cell().end_cell());
  if (chars.begin_parse().slice_empty?()) {
    return ans.end_cell();
  } 
  return ans.store_ref(chars).end_cell();
}

  ;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
    return cipher(0, text, shift);
  }

  ;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
    return cipher(-1, text, shift); 
  }

